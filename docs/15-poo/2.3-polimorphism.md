# Programaci√≥n Orientada a Objetos en JS {docsify-ignore-all}

## Polimorfismo

La palabra viene del griego **poli** (muchos) y **morfo** (forma), muchas formas.

**Definici√≥n formal:** Propiedad que nos permite enviar mensajes sint√°cticamente iguales (es decir, que se llaman igual y toman los mismos par√°metros) a objetos de tipos distintos. El √∫nico requisito que deben cumplir los objetos que se utilizan de manera **polim√≥rfica** es saber responder al mensaje que se les env√≠a.

_tl;dr_ Propiedad que permite que objetos de diferentes tipos/'clases' puedan responder a los mismos mensajes/m√©todos.

Esto se logra sobreescribiendo un m√©todo de una clase en una subclase.

Propiedad que nos permite tratar de la misma forma a objetos de tipos diferentes

Cuando hablamos de **objetos de diferentes tipos** en el contexto de **polimorfismo**, nos referimos a objetos cuyos prototipos son diferentes √≥ que son (con muchas comillas) **instancias** de diferentes **clases**.

### Usando prototipos

#### Estableciendo la herencia

```js
const User = {
  active: false,
  sayHello() {
    console.log(`${this.name} says hi!`)
  }
};

const Student = {
  name: 'Morty',
  major: 'JavaScript'
};

const Professor = {
  name: 'Rick',
  teaching: ['JavaScript', 'NodeJS', 'Physics']
};

Object.setPrototypeOf(Student, User);
Object.setPrototypeOf(Professor, User);

Student.active = true;

const newUsers = [Student, Professor];

newUsers.forEach(user => user.sayHello())
```

#### Sobreescribiendo m√©todos del prototipo

```js
const User = {
  active: false,
  describe() {
    console.log(`${this.name} says hi!`)
  }
};

const Student = {
  name: 'Morty',
  major: 'JavaScript',
  describe() {
    console.log(`${this.name} studies ${this.major}`);
  }
};

const Professor = {
  name: 'Rick',
  teaching: ['JavaScript', 'NodeJS', 'Physics'],
  describe() {
    console.log(`${this.name} teaches ${this.teaching}`);
  }
};

Object.setPrototypeOf(Student, User);
Object.setPrototypeOf(Professor, User);

Student.active = true;

const newUsers = [Student, Professor];

newUsers.forEach(user => user.describe())
```

### Usando  `Class`

```js
class Animal {
  constructor(name) {
    this._name = name;
  }

  makeSound() {
    console.log('üîâ Default sound!');
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name);
  }

  makeSound() {
    console.log('üê∂ WoOof!')
  }
}

class Cat extend  s Animal {
  constructor(name) {
    super(name);
  }

  makeSound() {
    console.log('üê± MeowW!')
  }
}

const animal = new Animal('Doggie');
animal.makeSound();

const dog = new Dog('Beethoven');
const cat = new Cat('Felix');
dog.makeSound();
cat.makeSound();
```

## _Getters_ & _Setters_

```js
const person = {
  firstName: 'Aquiles',
  lastName: 'Bailoyo',
  // the old way...
  getFullName() {
    return `${this.firstName} ${this.lastName}`
  }
};

console.log(person.getFullName());
```

*Contras de usar este approach:*

1. Una vez creado el objeto, sus propiedades `firstName`y `lastName` son **read-only** (s√≥lo lectura), no podemos modificar el valor.
2. Tenemos que utilizar un **m√©todo** para algo que tal vez estar√≠a bueno tener como el valor de una **propiedad** com√∫n.

### Usando `get`

```js
const person = {
  firstName: 'Aquiles',
  lastName: 'Bailoyo',
  get fullName() {
    return `${this.firstName} ${this.lastName}`
  }
};

console.log(person.fullName);
```

### Usando `get` y `set`

```js
const person = {
  firstName: 'Aquiles',
  lastName: 'Bailoyo',
  get fullName() {
    return `${this.firstName} ${this.lastName}`
  },
  set fullName(name) {
    const fullName = name.split(' ');
    this.firstName = fullName[0];
    this.lastName = fullName[1];
    console.info(`${name} has been set as person's full name.`)
  }
};

// usando el _setter_
person.fullName = 'Armando Paredes';
// usando el _getter_
console.log(person.fullName);
```

### tl;dr

Los **getters** y **setters** son **m√©todos** definidos en un objeto o clase, que se ven y utilizamos **como si fueran propiedades**. Forman parte de la **interfaz** del objeto, es decir, son p√∫blicos. Es una caracteristica de **ES6/2015+**.

La idea es que accedamos y modifiquemos propiedades del objeto de forma segura y controlada, a trav√©s de los **getters** y **setters**.

- Usamos **getters** para **acceder/obtener** al valor de una propiedad.
- Usamos **setters** para **setear/modificar/mutar** el valor de una propiedad.
